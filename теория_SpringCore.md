## Spring
### Bean 
**Bean**- это просто Java- объект.Когда Java объекты создаются с помощью Spring'a ,они называются бинами (beans)\
Бины создаются из Java классов (так же, как и обычные объекты)\
```
 <bean id="testBean" class="org.example.model.TestBean">
        <constructor-arg value="Marsel"/>
    </bean>
```

### Типичные шаги в работе со Spring :
 - Создаем Java - классы (будущие бины)
 - Создаем и связываем  бины  с помощью Spring (аннотации,XML или Java код)
 - При использовании, все объекты (бины) берутся из контейнера Spring.

### Способы внедрения зависимостей:
 - Через конструктор 
 - Через сеттер 

 Есть множество конфигураций,как внедрять зависимости (**scope**,**factory method** и  тд)\
 Можно внедрять через XML, аннотации или Java-код\
 Процесс внедрения можно автоматизировать (Autowiring)

когда мы хотим сослаться на значения  во внешнем файле (например, application.property),можно прописать конструкццию:
```
<context:property-placeholder location="classpath:musicPlayer.properties"
```
таким образом, Spring найдет эти значения

Для внедрения зависимости через "сеттер" необходимо иметь в классе пустой конструктор.

**Scope** задаёт то, как Spring  будет создавать бины.
Если мы явно не указываем scope, то по умолчанию будет использоваться скоуп "Singleton"\
- По уиолчанию создается один объект (он создается до вызова метода getBean()).
- При всех вызовах getBean() возвращается ссылка на один и тот же единственный объект.
Проблема в том, что если  этот объект изменить (например, громкость в MusicPlayer), то это изменение произойдет на всех объектах, использующих данную зависимость.
```
MusicPlayer firstMusicPlayer = context.getBean("musicPlayer",MusicPlayer.class);
MusicPlayer secondMusicPlayer = context.getBean("musicPlayer",MusicPlayer.class);
boolean comparsion = firstMusicPlayer == secondMusicPlayer;
  System.out.println(comparsion); //true 
```
Этот скоуп чаще всего используется тогда, когда у нашего Бина нет изменяемых состояний (stateless).

**Prototype** - скоуп, который каждый раз создает новый объект при вызове getBean()
```
MusicPlayer firstMusicPlayer = context.getBean("musicPlayer",MusicPlayer.class);
MusicPlayer secondMusicPlayer = context.getBean("musicPlayer",MusicPlayer.class);
boolean comparsion = firstMusicPlayer == secondMusicPlayer;
  System.out.println(comparsion); //false
```
Этот скоуп чаще всего используется тогда, когда у нашего Бина есть изменяемые состояния (stateful).\
Также есть скоупы :\
**request**,**session**,**global-session** 

### Жизненный цикл бина
запуск Spring приложения -> запуск Spring контейнера -> создание объекта бина ->\
-> в бин внедряютмя зависимости (Dependency injection)->вызывается указанный init-method->
-> бин готов к использованию-> использование бина пользователем->
вызывается указанный destroy-method->остановка Spring приложения

**init-method**-метод,который используется в ходе инициализации бина.
- инициализация ресурсов,обращение к внешним файлам, запуск БД\
**destroy-method**-метод, который запускается в ходе уничтожения бина (при завершении приложения). \
-очищение ресурсов, закрытие потоков ввода-вывода,закрытие доступа к БД

### Тонкости init и destroy методов
- **модификатор доступа**\ у этих методов может быть любой модификатор доступа (public,protected,private)\ 
- **тип возвращаемого значения**\ может быть любой, но чаще используется void (так как нет возможности получить возвращаемое значение).
- **название метода**\ название может быть любым
- **аргументы метода** эти методы не должны принимать на вход какие либо аргументы. 
- для бинов со scope "Prototype" Spring не вызывает destroy метод.\
 Spring не берет на себя полный жизненный цикл бинов со scope "prototype".Spring отдает prototype бины клиенту и больше о них не заботится(в отличие от singleton бинов).



**factory-method**-это паттерн программирования.

Паттерн программирования **factory-method**(фабричный метод) предлагает создавать объекты не напрямую ,используя оператор new, а через вызов особого фабричного метода.
Объекты все равно будут создаваться при помощи **new**, но делать это будет фабричный метод (иногда это бывает полезно).\
Если  объекты класса созлаются фабричным методом,то можно определить factory-method:
```
<bean id="musicBean" 
      class="org.example.model.ClassicalMusic"
      factory-method="getClassicalMusic">
</bean>
```
несмотря на то,что фабричный метод каждый раз возвращает разный объект,\
Spring вызовет фабричный  метод и создаст объект только один раз,все вызовы метода getBean()будут ссылаться на единственный созданный объект,\
 так как скоуп "singleton".

 ## Аннотации
 **Java аннотации**- это специальный тип комментариев в коде, с помощью которых можно:\
 - Передавать какие-либо инструкции для Java компилятора (пример: аннотация @Override)
 - Передавать какие-либо инструкции для анализаторов исходного кода 
 - Передавать метаданные, которые могут быть использованы либо Java приложением (с помощью рефлексии),либо другими приложениями или фреймворками\
 (пример: Spring Framework)

Для чего использовать аннотации?\
- Короче, чем XML конфигурация 
- Удобнее, чем XML конфигурация 
- Код становится более читабельным

Как работает конфигурация с помощью аннотаций?\
Spring сканирует все классы-> Находит классы со специальными аннотациями и автоматически создает бины из этих классов.

### @Component
- Помечаем ей класс, если хотим, чтобы Spring Framework создал бин из этого класса.
- Именно эту аннотацию Spring Framework ищет, когда сканирует все классы.
- Можно указать **id** для создаваемого бина, можно не указывать (тогда название будет "название_класса_с_иаленькой буквы")
Если есть конфигурационный applicationcontext.xml файл, то в него нужно прописать конструкцию для сканирования всех классов на аннотацию @Component

```<context:component-scan base-package="org.example.annotations_intro"/>```

### Внедрение зависимостей с помощью аннотаций.
**@Autowired**\
Данная аннотация позволяет внедрять зависимость автоматически .
Как работает аннотация @Autowired ?

```@Autowired
public MusicPlayer(Music music) { this.music = music;}
```
- Spring сканирует все классы с аннотацией **@Component** и создает бины для этих классов 
- Spring сканирует все созданные бины и проверяет, подходит ли хотя бы один бин в качестве зависимости там, где мы указали аннотацию @Autowired
- Если находится один подходящий бин,то он внедряется в качестве зависимости
- Если не находится, то вылетает ошибка
- Если под одну зависимость подходят несколько бинов - **неоднозначность**

Аннотация @Autowired подбирает подходящие бины по их типу (класс или интерфейс)\
Пример1:\
```
@Autowired
public MusicPLayer(Music music) {this.music = music;}
// в данном примере Spring для внедрения будет искать бин, реализующий интерфейс Music
```
Пример2:\
```
@Autowired 
public MusicPlayer(ClassicalMusic classicalMusic) {this.classicalMusic = classicalMusic;}
// в данном примере Spring будет искать бин класса ClassicalMusic
```

Аннотацию @Autowired можно использовать на полях, сеттерах, конструкторах\
Аннотация @Autowired внедрит зависимость в приватное поле  даже если нет конструктора или сеттера. Делает она это с помощью Рефлексии (Java Reflection API)

### Аннотация @Qualifier
когда для зависимости потенциально подходит несколько бинов, используется для уточнения,какой бин использовать, аннотация @Qualifier
```
@Autowired
@Qualifier("rockMusic") //указываем id того бина, который хотим внедрить
private Music music;

```
Когда внедрение производится  с помощью конструктора, для уточнения зависимостей небходимо использовать такой синтаксис:
```
@Autowired
public MusicPlayer (@Qualifier("rockMusic") Music music1,
                    @Qualifier("classicalMusic") Music music2) {
    this.music1 = music1;
    this.music2 = music2;                     
}
```
Аннотацию @Qualifier необходимо использовать рядом с аргументами конструктора

### Варианты конфигурации Spring приложения 
- вся конфигурация на xml
- XML+ аннотации 
- Java код + аннотации (xml конфигурации больше нет)   

## @Configuration 
Помечает Java класс,который мы хотим использовать для  конфигурации Spring приложения
    
    ```
    @Configuration
    public class SpringConfig {
    }
    ```
Пустой конфигурационный Java класс равен по функционалу пустому конфигурационному XML файлу\
Для каждого XML тега есть соответствующая аннотация\
Если раньше использовали для задания конфигурации **СlassPathXmlApplicationContext**,то для создания контекста с помощью конфигурационного Java класса используется 
**AnnotationConfigApplicationContext**.\

**@PropertySource**- для внедрения значений из внешнего файла (в аргументах прописывается путь до файла, содержащего внедряемые значения).
```
@PropertySource(classpath:musicPlayer.properties)
```







 




 

